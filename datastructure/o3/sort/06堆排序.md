## [堆排序][0]
<font face=黑体>

### **概要**

本章介绍排序算法中的堆排序。

目录   
1. [堆排序介绍][1]   
2. [堆排序图文说明][2]   
3. [堆排序的时间复杂度和稳定性][3]   
4. [堆排序实现][4]   
4.1 [堆排序C实现][5]   
4.2 [堆排序C++实现][6]   
4.3 [堆排序Java实现][7]

转载请注明出处：[http://www.cnblogs.com/skywang12345/p/3602162.html][0]

- - -

**更多排序和算法请参考：** [数据结构与算法系列 目录][8]

### **堆排序介绍**

堆排序(Heap Sort)是指利用堆这种数据结构所设计的一种排序算法。   
因此，学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先了解[堆][9](建议可以通过[二叉堆][9]，[左倾堆][10]，[斜堆][11]，[二项堆][12]或[斐波那契堆][13]等文章进行了解)，然后再来学习本章。

我们知道，堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。   
鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。

最大堆进行升序排序的基本思想：   
<font face=楷体>
① 初始化堆：将数列`a[1...n]`构造成最大堆。   
② 交换数据：将`a[1]`和`a[n]`交换，使`a[n]`是`a[1...n]`中的最大值；然后将`a[1...n-1]`重新调整为最大堆。 接着，将`a[1]`和`a[n-1]`交换，使`a[n-1]`是`a[1...n-1]`中的最大值；然后将`a[1...n-2]`重新调整为最大值。 依次类推，直到整个数列都是有序的。</font>

下面，通过图文来解析堆排序的实现过程。注意实现中用到了"数组实现的二叉堆的性质"。   
在第一个元素的索引为 0 的情形中：   
性质一：索引为i的左孩子的索引是 (2\*i+1);   
性质二：索引为i的左孩子的索引是 (2\*i+2);   
性质三：索引为i的父结点的索引是 floor((i-1)/2);

![](../img/151545571211442.jpg)

例如，对于最大堆{110,100,90,40,80,20,60,10,30,50,70}而言：索引为0的左孩子的所有是1；索引为0的右孩子是2；索引为8的父节点是3。

### **堆排序图文说明**

堆排序(升序)代码

```c
    /* 
     * (最大)堆的向下调整算法
     *
     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
     *
     * 参数说明：
     *     a -- 待排序的数组
     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
     *     end   -- 截至范围(一般为数组中最后一个元素的索引)
     */
    void maxheap_down(int a[], int start, int end)
    {
        int c = start;            // 当前(current)节点的位置
        int l = 2*c + 1;        // 左(left)孩子的位置
        int tmp = a[c];            // 当前(current)节点的大小
        for (; l <= end; c=l,l=2*l+1)
        {
            // "l"是左孩子，"l+1"是右孩子
            if ( l < end && a[l] < a[l+1])
                l++;        // 左右两孩子中选择较大者，即m_heap[l+1]
            if (tmp >= a[l])
                break;        // 调整结束
            else            // 交换值
            {
                a[c] = a[l];
                a[l]= tmp;
            }
        }
    }
    
    /*
     * 堆排序(从小到大)
     *
     * 参数说明：
     *     a -- 待排序的数组
     *     n -- 数组的长度
     */
    void heap_sort_asc(int a[], int n)
    {
        int i;
    
        // 从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。
        for (i = n / 2 - 1; i >= 0; i--)
            maxheap_down(a, i, n-1);
    
        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
        for (i = n - 1; i > 0; i--)
        {
            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
            swap(a[0], a[i]);
            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
            // 即，保证a[i-1]是a[0...i-1]中的最大值。
            maxheap_down(a, 0, i-1);
        }
    }
```

`heap_sort_asc(a, n)`的作用是：对数组a进行升序排序；其中，a是数组，n是数组长度。   
`heap_sort_asc(a, n)`的操作分为两部分：初始化堆 和 交换数据。   
`maxheap_down(a, start, end)`是最大堆的向下调整算法。

下面演示`heap_sort_asc(a, n)`对a={20,30,90,40,70,110,60,10,100,50,80}, n=11进行堆排序过程。下面是数组a对应的初始化结构：

![](../img/151547560909494.jpg)

**1 初始化堆**

在堆排序算法中，首先要将待排序的数组转化成二叉堆。   
下面演示将数组{20,30,90,40,70,110,60,10,100,50,80}转换为最大堆{110,100,90,40,80,20,60,10,30,50,70}的步骤。

**1.1 i=11/2-1，即i=4**

![](../img/151549357156092.jpg)

上面是`maxheap_down(a, 4, 9)`调整过程。`maxheap_down(a, 4, 9)`的作用是将`a[4...9]`进行下调；`a[4]`的左孩子是`a[9]`，右孩子是`a[10]`。调整时，选择左右孩子中较大的一个(即`a[10]`)和`a[4]`交换。

**1.2 i=3**

![](../img/151550457307269.jpg)

上面是`maxheap_down(a, 3, 9)`调整过程。`maxheap_down(a, 3, 9)`的作用是将`a[3...9]`进行下调；`a[3]`的左孩子是`a[7]`，右孩子是`a[8]`。调整时，选择左右孩子中较大的一个(即`a[8]`)和`a[4]`交换。

**1.3 i=2**

![](../img/151551282937167.jpg)  

上面是`maxheap_down(a, 2, 9)`调整过程。`maxheap_down(a, 2, 9)`的作用是将`a[2...9]`进行下调；`a[2]`的左孩子是`a[5]`，右孩子是`a[6]`。调整时，选择左右孩子中较大的一个(即`a[5]`)和`a[2]`交换。

**1.4 i=1**

![](../img/151552295278892.jpg)  

上面是`maxheap_down(a, 1, 9)`调整过程。`maxheap_down(a, 1, 9)`的作用是将`a[1...9]`进行下调；`a[1]`的左孩子是`a[3]`，右孩子是`a[4]`。调整时，选择左右孩子中较大的一个(即`a[3]`)和`a[1]`交换。交换之后，`a[3]`为30，它比它的右孩子`a[8]`要大，接着，再将它们交换。

**1.5 i=0**

![](../img/151553325277045.jpg)  

上面是maxheap_down(a, 0, 9)调整过程。maxheap_down(a, 0, 9)的作用是将`a[0...9]`进行下调；`a[0]`的左孩子是`a[1]`，右孩子是`a[2]`。调整时，选择左右孩子中较大的一个(即`a[2]`)和`a[0]`交换。交换之后，`a[2]`为20，它比它的左右孩子要大，选择较大的孩子(即左孩子)和`a[2]`交换。

调整完毕，就得到了最大堆。此时，数组{20,30,90,40,70,110,60,10,100,50,80}也就变成了{110,100,90,40,80,20,60,10,30,50,70}。

**第2部分 交换数据**

在将数组转换成最大堆之后，接着要进行交换数据，从而使数组成为一个真正的有序数组。   
交换数据部分相对比较简单，下面仅仅给出将最大值放在数组末尾的示意图。

![](../img/151554424963237.jpg)

上面是当n=10时，交换数据的示意图。   
当n=10时，首先交换`a[0]`和`a[10]`，使得`a[10]`是`a[0...10]`之间的最大值；然后，调整`a[0...9]`使它称为最大堆。交换之后：`a[10]`是有序的！   
当n=9时， 首先交换`a[0]`和`a[9]`，使得`a[9]`是`a[0...9]`之间的最大值；然后，调整`a[0...8]`使它称为最大堆。交换之后：`a[9...10]`是有序的！   
...   
依此类推，直到`a[0...10]`是有序的。

### **堆排序的时间复杂度和稳定性**

**堆排序时间复杂度**  
堆排序的时间复杂度是O(N\*lgN)。   
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？   
堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N\*lgN)。

**堆排序稳定性**  
堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。   
_算法稳定性 -- 假设在数列中存在`a[i]=a[j]`，若在排序之前，`a[i]`在`a[j]`前面；并且排序之后，`a[i]`仍然在`a[j]`前面。则这个排序算法是稳定的！_

### **堆排序实现**

下面给出堆排序的三种实现：C、C++和Java。这三种实现的原理和输出结果都是一样的，每一种实现中都包括了"最大堆对应的升序排列"和"最小堆对应的降序排序"。   
**堆排序C实现**  
实现代码(heap_sort.c)

```c
/**
 * 堆排序：C 语言
 *
 * @author skywang
 * @date 2014/03/12
 */

#include <stdio.h>

// 数组长度
#define LENGTH(array) ( (sizeof(array)) / (sizeof(array[0])) )
#define swap(a,b) (a^=b,b^=a,a^=b)

/* 
 * (最大)堆的向下调整算法
 *
 * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
 *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
 *     end   -- 截至范围(一般为数组中最后一个元素的索引)
 */
void maxheap_down(int a[], int start, int end)
{
    int c = start;            // 当前(current)节点的位置
    int l = 2*c + 1;        // 左(left)孩子的位置
    int tmp = a[c];            // 当前(current)节点的大小
    for (; l <= end; c=l,l=2*l+1)
    {
        // "l"是左孩子，"l+1"是右孩子
        if ( l < end && a[l] < a[l+1])
            l++;        // 左右两孩子中选择较大者，即m_heap[l+1]
        if (tmp >= a[l])
            break;        // 调整结束
        else            // 交换值
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}

/*
 * 堆排序(从小到大)
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void heap_sort_asc(int a[], int n)
{
    int i;

    // 从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。
    for (i = n / 2 - 1; i >= 0; i--)
        maxheap_down(a, i, n-1);

    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i = n - 1; i > 0; i--)
    {
        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
        swap(a[0], a[i]);
        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
        // 即，保证a[i-1]是a[0...i-1]中的最大值。
        maxheap_down(a, 0, i-1);
    }
}

/* 
 * (最小)堆的向下调整算法
 *
 * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
 *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
 *     end   -- 截至范围(一般为数组中最后一个元素的索引)
 */
void minheap_down(int a[], int start, int end)
{
    int c = start;            // 当前(current)节点的位置
    int l = 2*c + 1;        // 左(left)孩子的位置
    int tmp = a[c];            // 当前(current)节点的大小
    for (; l <= end; c=l,l=2*l+1)
    {
        // "l"是左孩子，"l+1"是右孩子
        if ( l < end && a[l] > a[l+1])
            l++;        // 左右两孩子中选择较小者
        if (tmp <= a[l])
            break;        // 调整结束
        else            // 交换值
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}

/*
 * 堆排序(从大到小)
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void heap_sort_desc(int a[], int n)
{
    int i;

    // 从(n/2-1) --> 0逐次遍历每。遍历之后，得到的数组实际上是一个最小堆。
    for (i = n / 2 - 1; i >= 0; i--)
        minheap_down(a, i, n-1);

    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i = n - 1; i > 0; i--)
    {
        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。
        swap(a[0], a[i]);
        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。
        // 即，保证a[i-1]是a[0...i-1]中的最小值。
        minheap_down(a, 0, i-1);
    }
}

void main()
{
    int i;
    int a[] = {20,30,90,40,70,110,60,10,100,50,80};
    int ilen = LENGTH(a);

    printf("before sort:");
    for (i=0; i<ilen; i++)
        printf("%d ", a[i]);
    printf("\n");

    heap_sort_asc(a, ilen);            // 升序排列
    //heap_sort_desc(a, ilen);        // 降序排列

    printf("after  sort:");
    for (i=0; i<ilen; i++)
        printf("%d ", a[i]);
    printf("\n");
}
```

**堆排序C++实现**  
实现代码(HeapSort.cpp)

```cpp
/**
 * 堆排序：C++
 *
 * @author skywang
 * @date 2014/03/11
 */

#include <iostream>
using namespace std;

/* 
 * (最大)堆的向下调整算法
 *
 * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
 *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
 *     end   -- 截至范围(一般为数组中最后一个元素的索引)
 */
void maxHeapDown(int* a, int start, int end)
{
    int c = start;            // 当前(current)节点的位置
    int l = 2*c + 1;        // 左(left)孩子的位置
    int tmp = a[c];            // 当前(current)节点的大小
    for (; l <= end; c=l,l=2*l+1)
    {
        // "l"是左孩子，"l+1"是右孩子
        if ( l < end && a[l] < a[l+1])
            l++;        // 左右两孩子中选择较大者，即m_heap[l+1]
        if (tmp >= a[l])
            break;        // 调整结束
        else            // 交换值
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}

/*
 * 堆排序(从小到大)
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void heapSortAsc(int* a, int n)
{
    int i,tmp;

    // 从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。
    for (i = n / 2 - 1; i >= 0; i--)
        maxHeapDown(a, i, n-1);

    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i = n - 1; i > 0; i--)
    {
        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
        tmp = a[0];
        a[0] = a[i];
        a[i] = tmp;
        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
        // 即，保证a[i-1]是a[0...i-1]中的最大值。
        maxHeapDown(a, 0, i-1);
    }
}

/* 
 * (最小)堆的向下调整算法
 *
 * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
 *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
 *     end   -- 截至范围(一般为数组中最后一个元素的索引)
 */
void minHeapDown(int* a, int start, int end)
{
    int c = start;            // 当前(current)节点的位置
    int l = 2*c + 1;        // 左(left)孩子的位置
    int tmp = a[c];            // 当前(current)节点的大小
    for (; l <= end; c=l,l=2*l+1)
    {
        // "l"是左孩子，"l+1"是右孩子
        if ( l < end && a[l] > a[l+1])
            l++;        // 左右两孩子中选择较小者
        if (tmp <= a[l])
            break;        // 调整结束
        else            // 交换值
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}

/*
 * 堆排序(从大到小)
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void heapSortDesc(int* a, int n)
{
    int i,tmp;

    // 从(n/2-1) --> 0逐次遍历每。遍历之后，得到的数组实际上是一个最小堆。
    for (i = n / 2 - 1; i >= 0; i--)
        minHeapDown(a, i, n-1);

    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i = n - 1; i > 0; i--)
    {
        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。
        tmp = a[0];
        a[0] = a[i];
        a[i] = tmp;
        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。
        // 即，保证a[i-1]是a[0...i-1]中的最小值。
        minHeapDown(a, 0, i-1);
    }
}

int main()
{
    int i;
    int a[] = {20,30,90,40,70,110,60,10,100,50,80};
    int ilen = (sizeof(a)) / (sizeof(a[0]));

    cout << "before sort:";
    for (i=0; i<ilen; i++)
        cout << a[i] << " ";
    cout << endl;

    heapSortAsc(a, ilen);            // 升序排列
    //heapSortDesc(a, ilen);        // 降序排列

    cout << "after  sort:";
    for (i=0; i<ilen; i++)
        cout << a[i] << " ";
    cout << endl;

    return 0;
}
```

**堆排序Java实现**  
实现代码(HeapSort.java)

```java
/**
 * 堆排序：Java
 *
 * @author skywang
 * @date 2014/03/11
 */

public class HeapSort {

    /* 
     * (最大)堆的向下调整算法
     *
     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
     *
     * 参数说明：
     *     a -- 待排序的数组
     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
     *     end   -- 截至范围(一般为数组中最后一个元素的索引)
     */
    public static void maxHeapDown(int[] a, int start, int end) {
        int c = start;            // 当前(current)节点的位置
        int l = 2*c + 1;        // 左(left)孩子的位置
        int tmp = a[c];            // 当前(current)节点的大小

        for (; l <= end; c=l,l=2*l+1) {
            // "l"是左孩子，"l+1"是右孩子
            if ( l < end && a[l] < a[l+1])
                l++;        // 左右两孩子中选择较大者，即m_heap[l+1]
            if (tmp >= a[l])
                break;        // 调整结束
            else {            // 交换值
                a[c] = a[l];
                a[l]= tmp;
            }
        }
    }

    /*
     * 堆排序(从小到大)
     *
     * 参数说明：
     *     a -- 待排序的数组
     *     n -- 数组的长度
     */
    public static void heapSortAsc(int[] a, int n) {
        int i,tmp;

        // 从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。
        for (i = n / 2 - 1; i >= 0; i--)
            maxHeapDown(a, i, n-1);

        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
        for (i = n - 1; i > 0; i--) {
            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
            tmp = a[0];
            a[0] = a[i];
            a[i] = tmp;
            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
            // 即，保证a[i-1]是a[0...i-1]中的最大值。
            maxHeapDown(a, 0, i-1);
        }
    }

    /* 
     * (最小)堆的向下调整算法
     *
     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
     *
     * 参数说明：
     *     a -- 待排序的数组
     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
     *     end   -- 截至范围(一般为数组中最后一个元素的索引)
     */
    public static void minHeapDown(int[] a, int start, int end) {
        int c = start;            // 当前(current)节点的位置
        int l = 2*c + 1;        // 左(left)孩子的位置
        int tmp = a[c];            // 当前(current)节点的大小

        for (; l <= end; c=l,l=2*l+1) {
            // "l"是左孩子，"l+1"是右孩子
            if ( l < end && a[l] > a[l+1])
                l++;        // 左右两孩子中选择较小者
            if (tmp <= a[l])
                break;        // 调整结束
            else {            // 交换值
                a[c] = a[l];
                a[l]= tmp;
            }
        }
    }

    /*
     * 堆排序(从大到小)
     *
     * 参数说明：
     *     a -- 待排序的数组
     *     n -- 数组的长度
     */
    public static void heapSortDesc(int[] a, int n) {
        int i,tmp;

        // 从(n/2-1) --> 0逐次遍历每。遍历之后，得到的数组实际上是一个最小堆。
        for (i = n / 2 - 1; i >= 0; i--)
            minHeapDown(a, i, n-1);

        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
        for (i = n - 1; i > 0; i--) {
            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。
            tmp = a[0];
            a[0] = a[i];
            a[i] = tmp;
            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。
            // 即，保证a[i-1]是a[0...i-1]中的最小值。
            minHeapDown(a, 0, i-1);
        }
    }

    public static void main(String[] args) {
        int i;
        int a[] = {20,30,90,40,70,110,60,10,100,50,80};

        System.out.printf("before sort:");
        for (i=0; i<a.length; i++)
            System.out.printf("%d ", a[i]);
        System.out.printf("\n");

        heapSortAsc(a, a.length);            // 升序排列
        //heapSortDesc(a, a.length);        // 降序排列

        System.out.printf("after  sort:");
        for (i=0; i<a.length; i++)
            System.out.printf("%d ", a[i]);
        System.out.printf("\n");
    }
}
```


它们的输出结果：

    before sort:20 30 90 40 70 110 60 10 100 50 80 
    after  sort:10 20 30 40 50 60 70 80 90 100 110 

</font>

[0]: http://www.cnblogs.com/skywang12345/p/3602162.html
[1]: #a1
[2]: #a2
[3]: #a3
[4]: #a4
[5]: #a41
[6]: #a42
[7]: #a43
[8]: http://www.cnblogs.com/skywang12345/p/3603935.html
[9]: http://www.cnblogs.com/skywang12345/p/3610187.html
[10]: http://www.cnblogs.com/skywang12345/p/3638327.html
[11]: http://www.cnblogs.com/skywang12345/p/3638493.html
[12]: http://www.cnblogs.com/skywang12345/p/3655900.html
[13]: http://www.cnblogs.com/skywang12345/p/3659060.html
