# [背包问题吐血详解][0]

 2014-10-18 13:29  1676人阅读  

 本文章已收录于：


版权声明：本文为博主原创文章，未经博主允许不得转载。

背包问题我真是学一次忘一次，很多dp问题也是由这个衍生而来，今天终于痛下决心写个博客供自己日后参考

问题描述：

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

基本思路 ：  
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是： tab[i][j] = max(tab[i-1][j-weight[i]]+value[i],tab[i-1][j]) ({i,j|0< i<=n,0<=j<=total})

其中i表示放第i个物品，j表示背包所容纳的重量，那么tab[i-1][j-weight[i]]+value[i]表示放入第i物品，刚开始接触会有疑问，tab[i-1][j-weight[i]]这个值，可以这样理解：tab[i-1][j]为装到上一个物品在背包j容量时的最佳值，那么如果我要求 在j容量的时候放入现在的i物品的价值 ，那么是不是要先得到容量为（j-weight[i]）时候的价值，即先得到 **tab[i-1][j-weight[i]]**， 所以 tab[i-1][j-weight[i]]+value[i] 为放入第i物品的价值； tab[i-1][j] 就是不放入第i个物品。

 例子：5个物品，（重量，价值）分别为：（5，12），（4，3），（7，10），（2，3），（6，6）。

背包容量 | 0 | 1 | 2 | 3 | 4 | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15
-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
5物品    | 0 | 0 | 0 | 0 | 0 | 0  | 6  | 12 | 12 | 15 | 15 | 18 | 22 | 22 | 25 | 25
4物品    | 0 | 0 | 3 | 3 | 3 | 3  | 3  | 12 | 12 | 15 | 15 | 18 | 22 | 22 | 25 | 25
3物品    | 0 | 0 | 0 | 0 | 0 | 0  | 0  | 12 | 12 | 15 | 15 | 15 | 22 | 22 | 22 | 22
2物品    | 0 | 0 | 0 | 0 | 3 | 12 | 12 | 12 | 12 | 15 | 15 | 15 | 15 | 15 | 15 | 15
1物品    | 0 | 0 | 0 | 0 | 0 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12

```
    for(int i = 1; i <= n; i++)
        {
            for(int j = 0; j <= W; j++)
            {
                if(j < w[i])    dp[i][j]  = dp[i-1][j];
                else dp[i][j] =  max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]);
            }
        }
```
  
优化空间复杂度：  
以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V)  
 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

伪代码如下：

 for i=1..N

 for v=V..0

 f[v]=max{f[v],f[v-c[i]]+w[i]};

 画个图给大家演示下

 也就是说此时的 f[v],f[v-c[i]] 是前面的

 假设体积是 10

 背包体积 ----- > >>>>

价值大小 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |  - | -
- | - | - | - | - | - | - | - | - | - | - | - | -
       2 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2  | 2  |放第一个物品 
       1 | 2 | 2 | 2 | 3 | 3 | 3 | 3 | 3 | 3 | 3  | 3  |放第二个
       5 | 3 | 2 | 2 | 3 | 3 | 3 | 8 | 8 | 8 | 8  | 8  | -
       4 | 4 | 2 | 2 | 3 | 3 | 3 | 8 | 8 | 8 | 8  | 12 | -
       3 | 5 

 可以看出 f[v]=max{f[v],f[v-c[i]]+w[i]};

 V 是从大到小的

 其中的 f[v],f[v-c[i]] 是前面的值 比较的结果赋值给 f[v]

 比如说当 i=5 的时候 f[v] >f[v-5] 注意两者都是 i=4 时候的值得出的结果 12 赋值到新的 f[v] 但是此时的 f[v] 是 i=5 的

 当把最后一行改写成 556 的时候我们可以看出 f[v-6]=f[4]+55 大于 f[v] 所以我们可以得出新的 f[v]=f[4]+55 这样结果就是取的体积为 12 6



        for(int i = 1; i <= n; i++)
        {
         for(int j = W; j >= w[i]; j--)
            dp[j] = max(dp[j], dp[j - w[i] + v[i]);
        }

二维转一维俗称滚动数组  
初始化细节： 

我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求 “ 恰好装满背包 ” 时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。

 如果是第一种问法， 要求恰好装满背包，那么在初始化时除了 f[0] 为 0 其它 f[1..V] 均设为 -∞ ， 这样就可以保证最终得到的 f[N] 是一种恰好装满背包的最优解。

 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 f[0..V] 全部设为 0 。

为什么呢？可以这样理解：初始化的 f 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可能被价值为 0 的 nothing“ 恰好装满 ” ，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是 -∞ 了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解 “ 什么都不装 ” ，这个解的价值为 0 ，所以初始时状态的值也就全部为 0 了。

这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。

  
再给一种理解方法：

01背包问题具体例子：假设现有容量10kg的背包，另外有3个物品，分别为a1，a2，a3。物品a1重量为3kg，价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6。将哪些物品放入背包可使得背包中的总价值最大？

这个问题有两种解法，动态规划和贪婪[算法][6]。本文仅涉及动态规划。

先不套用动态规划的具体定义，试着想，碰见这种题目，怎么解决?

首先想到的，一般是穷举法，一个一个地试，对于数目小的例子适用，如果容量增大，物品增多，这种方法就无用武之地了。

其次，可以先把价值最大的物体放入，这已经是贪婪算法的雏形了。如果不添加某些特定条件，结果未必可行。

最后，就是动态规划的思路了。先将原始问题一般化，欲求背包能够获得的总价值，即欲求前i个物体放入容量为m（kg）背包的最大价值c[i][m]——使用一个数组来存储最大价值，当m取10，i取3时，即原始问题了。而前i个物体放入容量为m（kg）的背包，又可以转化成前(i-1)个物体放入背包的问题。下面使用数学表达式描述它们两者之间的具体关系。

表达式中各个符号的具体含义。

w[i] : 第i个物体的重量；

p[i] : 第i个物体的价值；

c[i][m] ： 前i个物体放入容量为m的背包的最大价值；

c[i-1][m] ： 前i-1个物体放入容量为m的背包的最大价值；

c[i-1][m-w[i]] ： 前i-1个物体放入容量为m-w[i]的背包的最大价值；

由此可得：

c[i][m]=max{c[i-1][m-w[i]]+pi , c[i-1][m]}（下图将给出更具体的解释）

![][7]

根据上式，对物体个数及背包重量进行递推，列出一个表格（见下表），表格来自（ [http://blog.csdn.net/fg2006/article/details/6766384?reload][8] ） ，当逐步推出表中每个值的大小，那个最大价值就求出来了。推导过程中，注意一点，最好逐行而非逐列开始推导，先从编号为1的那一行，推出所有c[1][m]的值，再推编号为2的那行c[2][m]的大小。这样便于理解。

![][9]

[C语言][10]代码如下所示

```c++
#include <stdio.h>  
int c[10][100]={0};  
  
void knap(int m,int n){  
  
    int i,j,w[10],p[10];  
    for(i=1;i<n+1;i++)  
        scanf("%d,%d",&w[i],&p[i]);  
    for(j=0;j<m+1;j++)  
        for(i=0;i<n+1;i++)  
    {  
        if(j<w[i])  
        {  
            c[i][j]=c[i-1][j];  
            continue;  
        }else if(c[i-1][j-w[i]]+p[i]>c[i-1][j])  
            c[i][j]=c[i-1][j-w[i]]+p[i];  
        else  
            c[i][j]=c[i-1][j];  
    }  
      
}              
  
  
int main(){  
    int m,n;int i,j;  
    printf("input the max capacity and the number of the goods:\n");  
    scanf("%d,%d",&m,&n);  
    printf("Input each one(weight and value):\n");  
    knap(m,n);  
    printf("\n");  
   for(i=0;i<=n;i++)  
        for(j=0;j<=m;j++)  
       {  
     printf("%4d",c[i][j]);  
    if(m==j) printf("\n");  
    }  
}  
```

[0]: /u013445530/article/details/40210587
[5]: #
[6]: http://lib.csdn.net/base/datastructure
[7]: http://img.blog.csdn.net/20150115182444031
[8]: http://blog.csdn.net/fg2006/article/details/6766384?reload
[9]: http://img.blog.csdn.net/20150115182600408
[10]: http://lib.csdn.net/base/c